// Copyright 2019 Sic Studios. All rights reserved.
// Use of this source code is governed by our license that can be
// found in the LICENSE file.

#include "types/camera.comp"
#include "types/ray.comp"
#include "sampling/random.comp"

#define WORKGROUP_SIZE 32

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

layout(std430, set = 0, binding = 0) buffer buf {
   Ray rays[];
};

layout(set = 0, binding = 1) buffer buf2 {
   float seeds[];
};

layout(push_constant) uniform PushBlock {
    layout(offset=0)  Camera camera;
};


void main() {
  uint image_width = camera.x_res;
  uint image_height = camera.y_res;
  const uint x_coord = gl_GlobalInvocationID.x;
  const uint y_coord = gl_GlobalInvocationID.y;
  if (x_coord >= image_width|| y_coord >= image_height) {
    return;
  }

  uint index = image_width * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x;
  float seed = seeds[index];
  float rand1 = getRand(seed);

  float image_aspect_ratio = float(image_width) / float(image_height);

  float alpha = 2.0 * atan(1.0 / (2.0 * camera.focal_length));

  float s_1 = getRand(seed);
  float s_2 = getRand(seed);

  float pixel_normalized_x = (x_coord + s_1) / image_width;
  float pixel_normalized_y = (y_coord + s_2) / image_height; 

  float pixel_ndc_x = 2.0 * pixel_normalized_x - 1.0;
  float pixel_ndc_y = 2.0 * pixel_normalized_y - 1.0;

  float pixel_camera_x = pixel_ndc_x * camera.width * image_aspect_ratio * tan(alpha/2.0);
  float pixel_camera_y = pixel_ndc_y * camera.height * tan(alpha/2.0);

  vec4 camera_point = vec4(pixel_camera_x, pixel_camera_y, -1.0, 0.0);

  Ray ray;
  ray.origin = camera.position;
  ray.direction = normalize(-camera_point);
  ray.weight = vec4(1.0);
  ray.accumulation = vec4(0);
  ray.coord = vec2(pixel_ndc_x, pixel_ndc_y);
  ray.valid = 1;
  rays[index] = ray;
  seeds[index] = seed;
}