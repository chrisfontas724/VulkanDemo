// Copyright 2019 Sic Studios. All rights reserved.
// Use of this source code is governed by our license that can be
// found in the LICENSE file.

#include "types/ray.comp"
#include "types/intersection.comp"
#include "sampling/random.comp"

#define WORKGROUP_SIZE 512

layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1 ) in;

layout(std430, set = 0, binding = 0) buffer buf {
   Ray rays[];
};


layout(std140, set = 0, binding = 1) buffer buf1 {
    HitPoint hits[];
};


layout(set = 0, binding = 2) buffer buf2 {
    float rng_seeds[];
};


void main() {
    const uint index = gl_GlobalInvocationID.x;

    Ray input_ray = rays[index];
    HitPoint hit = hits[index];
    float rng_seed = rng_seeds[index];

    if (hit.t == -1.0) {
        input_ray.valid = 0;
        input_ray.origin = vec4(0.);
        input_ray.direction = vec4(0.);
        input_ray.weight = vec4(0.);
        hits[index].t = -1.0;
        rays[index] = input_ray;
        return;
    }


    float xi1 = getRand(rng_seed); 
    float xi2 = getRand(rng_seed); 

    float theta = acos(sqrt(1.0 -xi1));
    float phi = 2.0 * 3.14159265 * xi2;

    float xs = sin(theta) * cos(phi);
    float ys = cos(theta);
    float zs = sin(theta) * sin(phi);

    vec3 y = vec3(hit.norm.xyz);
    vec3 h = y;

    if (abs(h.x) <= abs(h.y) && abs(h.x) <= abs(h.z)) {
        h.x = 1.0;
    } else if (abs(h.y) <= abs(h.x) && abs(h.y) <= abs(h.z)) {
        h.y = 1.0;
    } else {
        h.z = 1.0;
    }

    vec3 x = normalize(cross(h,y));
    vec3 z = normalize(cross(x,y));

    vec3 new_dir = normalize(xs*x + ys*y + zs*z);
    float pdf = dot(new_dir, hit.norm.xyz) / 3.14159265;

    // Add a small epsilon to the new ray starting point to prevent self-intersection
    // with the object its already on.
    Ray new_ray = input_ray;
    new_ray.direction = vec4(new_dir, 0.0);
    new_ray.origin = hit.pos + 0.01 * new_ray.direction;
    new_ray.accumulation += input_ray.weight * hit.emission;

    // The new weight is BRDF * cosTheta / pdf.
    vec4 brdf = hit.col / vec4(3.14159265);
    float cos_theta = dot(new_ray.direction.xyz, hit.norm.xyz);
    new_ray.weight *= brdf * cos_theta / pdf;

    HitPoint blank_hit;
    blank_hit.t = -1.0;
    rays[index] = new_ray;
    hits[index] = blank_hit;
    rng_seeds[index] = rng_seed;
}